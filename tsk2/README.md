**Съдържание**

[1. Не знам какво да правя](#h1)

[2. ЗАДЪЛЖИТЕЛНО](#h2)

[3. Енкодинг](#h3)

[4. Изречения](#h4)

[5. Конзола](#h5)

# 1. Не знам какво да правя<a name="h1"></a>
Задачата е да се напише код на C, който чете текстов файл. Във файла има изречения на кирилица. Кода да оправя правописа на изреченията по [тези правила](Zadacha_za_korekcija_na_pravopisa.pdf), свалени от [мудъл](http://pct.tu-sofia.bg/moodle001/course/). Резултата след всяко изречение се показва в конзолата, като background-а на премахнатите символи е червен, а на добавените е зелен. Инфо за оцветяване на конзолата [от тук](colored_bash_output.rar), отново свалено от [мудъл](http://pct.tu-sofia.bg/moodle001/course/). Всички изречения се записват в друг текстов файл след обработка.

Качил съм файл за тестване **в два различни енкодинга** за *ориентир*. Не са сложени всички възможности и не гарантирам че правилата са 100% точни, но те и без това не са дефинирани много конкретно, така че не би трябвало да е голям проблем ако кода не се държи коректно на 1-2 места. Едни и същи изречения са повторени, като втория път показва в скоби кои правила тества изречението.

# 2. ЗАДЪЛЖИТЕЛНО<a name="h2"></a>
За да си спестите работа се запознайте с тази точка възможно най-рано в процеса
- Използвайте функциите за работа с файл от ниско ниво в Linux, част от задачата по условие. Функциите са ``open()``, ``close()``, ``read()``, ``write()``, ``lseek()`` и други ако ви трябват. Основната разлика е, че вместо с FILE* работите с int.
- Решете как ще се преборите с енкодинга. Разгледано в т.3
- Решете как ще четете по едно изречение от файла и как ще работите с буфера. Разгледано в т.4
- Решете как ще разграничавате между обикновени, премахнати и добавени символи, за да оцветявате конзолата правилно. Разгледано в т.5

# 3. Енкодинг<a name="h3"></a>
## 3.1 Какво е енкодинг?
Текст, както всичко друго в компютрите, се съхранява под формата на числа. Например символът 'h' се съхранява под един номер, 'Q' под друг и т.н. Кой точно номер използваме и каква схема прилагаме за четенето и писането на всеки символ се нарича енкодинг (Encoding).
## 3.2 Защо енкодинга е важен за тази задача?
Защото не работим с ASCII, а с кирилица. А щом работим с кирилица всичко може да се счупи. Ако енкодинга на две различни места се различават, и ако не го конвертираме, тези две места няма как да се разберат. Например, имаме текстов файл с един енкодинг и той съдържа само един символ 'ж'. После имаме .c файл с различен енкодинг и в него четем от файла и правим проверка ``if(charFromFile[0] == 'ж')``. При изпълнение на програмата най-вероятно този ``if`` ще даде ``false``, защото еднакви символи се съхраняват чрез различни числа при различните енкодинги.

Не е нужно всички енкодинги да са еднакви, но тогава трябва да се конвертират между различните точки. Тези точки са:
- текстовия файл с входните изречения, както и този с изходните
- сорс кода, тоест .c и .h файловете
- конзолата, в която се принтират промените
## 3.3 Кой енкодинг да ползвам?
Няма идеален вариант. Двата най-полезни за тази задача са UTF-8 и Windows-1251.
- [UTF-8](https://en.wikipedia.org/wiki/UTF-8) е универсален и работи общо взето с всичко. Можете да сте сигурни, че конзолата на Linux ще го визуализира и текстовите файлове може да се прочетат от всякъде. Проблема в случая е обработката им от кода. UTF-8 използва различна дължина на числата, за да съхранява различни символи. Например 'a' на латиница обикновено заема един байт, докато 'а' на кирилица заема два байта. Тук се появява проблема как ще съхранявате символите, тъй като char обикновено е само един байт. А ако използвате short може да се окаже, че сте съхранили два еднобайтови символа (напр. "?!") на едно място.
- [Windows-1251](https://en.wikipedia.org/wiki/Windows-1251), още познат като CP1251, използва втората половина на ASCII таблицата за кирилица. Тоест всичко ви се събира в един байт. Лесен за обработка и работа от програмата, използвате unsigned char и нямате никакви проблеми. Лошото тук е, че енкодинга много рядко се ползва и не се поддържа по подразбиране - тоест ще получите нечетими символи и нищо общо с кирилица при четене/писане. Да конвертирате и работите с такъв текстов файл е сравнително лесно, да пишете код на такъв зависи от средата (освен ако не пишете на обикновен текстов редактор), да го визлуализирате в конзолата на Linux е трудно, а в конзолата на Windows е почти невъзможно.

Имате много варианти, не е нужно енкодингите и на трите точки да са еднакви. Може и да работите с UTF-8 но вътрешно програмата да си работи с еднобайтови символи чрез конвертиране. Лично при мен всичко беше Windows-1251 и за да го визуализирам в конзолата използвах Linux команди. Варианта е малко мръсен, не гарантирам че ще ви пусне със същата схема.

# 4. Изречения<a name="h4"></a>
В задачата общо взето се изисква нещо такова:
```
open input file
while(has more to read in file){
  get 1 sentence in a buffer
  do work
  print result and append to output file
}
close input file
```
За целта ви трябва функция, с която четете по едно изречение. Най-лесно е да отделите изречение, като *четете от първата буква или цифра, срещнете поне един препинателен знак, и спирате да четете преди първата буква или цифра след препинателен знак*. Съответно трябва динамично да се заделя памет за буфер и той да се уголемява с ``realloc()`` ако не стига. Трябва и да си връщате четеца на файла, така че да не липсват символи при следващото минаване на функцията. Следете си дължата на буфера и имайте предвид, че ``realloc()`` може да смени адреса му - направете го като глобална променлива или ползвайте char**.

# 5. Конзола<a name="h5"></a>
Проблема с оцветяването може да изисква планиране напред, така че го слагам като отделна точка. Самото принтиране на цветен background в конзолата е лесно: използвате макросите от дадения архив. Хвърляте стринговете на bash и той си се оправя.

По-големия проблем е да разберете кои точно символи да оцветите. По време на обработката на изреченията буфера сменя дължината си, както и позициите на символите един спрямо друг. Предполагам е възможно да се анализира началното и крайното изречение и по разликите да се направи оцветяването. Аз го правих с втори буфер със същата дължина за флагове, и по време на изпълнение се слагат напр. флаг за премахване, добавяне, сменяне и т.н. Има реални алгоритми за такъв вид задача, потърсете какво ви изглежда лесно за имплементация. Във файла [diff.md](diff.md) слагам какво ми изплю чата (не съм го пробвал).

# [Успех, моряци!](https://youtu.be/mY6yIv-LsPw)
